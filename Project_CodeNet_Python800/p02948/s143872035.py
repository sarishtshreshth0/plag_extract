'''tanon  優先度付きキュー
t(=0 to M-1)日目に仕事を請けることを考えると、Ai>M-tなるiについては、
その仕事を請けるかどうかを考えなくて良い(∵この仕事を請けても、
Ai>M-t⇔Ai+t>Mより報酬はM日目より後にしかもらえません)。
したがって、tを大きい順に見ていくと、
M-1日目にはAi<=1なるiについて、報酬が最大となる仕事iを請けるべき、
M-2日目にはAi<=2なるiについて、まだ請けていない仕事の中で
報酬が最大となる仕事iを請けるべき、
…0日目にはAi<=Mなるiについて、まだ請けていない仕事の中で報酬が
最大となる仕事iを請けるべきであるといえます。
したがって、元の配列をAiの小さい順にソートしておき、
Ai=1の仕事について優先度付きキューに報酬Biを追加し、
優先度付きキューから取ってきた最大値を答えに加え、
次にAi=2の仕事について優先度付きキューに報酬Biを追加し、
優先度付きキューから取ってきた最大値を答えに加え、
…最後にAi=Mの仕事について優先度付きキューに報酬Biを追加し、
優先度付きキューから取ってきた最大値を答えに加えることで、
求める答えが得られます。
'''
import heapq
n,m=map(int,input().split())
arr=[list(map(int,input().split())) for _ in range(n)]
arr2=[[i,0] for i in range(1,m+2)] 
#すべてのAi=1 to Mについて報酬0の仕事を追加する
#こうすることで、必ずAiに対し、報酬0でも仕事がある⇒空振りがなくなる
arr.extend(arr2)
arr=sorted(arr,key=lambda x:x[0]) #Aiの小さい順にソート
q=[]
ans=0
pos=0
while 1:
 a,b=arr[pos]
 if a>m: #AiがMより大きければその仕事を請ける意味はない
   break
 if a==arr[pos+1][0]: 
  #Aiの値が等しいとき、その仕事を優先度付きキューに追加する
   heapq.heappush(q,-b)#マイナスを付けて、ヒープキューに入れている
 else:
   heapq.heappush(q,-b)
   ans-=heapq.heappop(q)#ヒープキューから最大値を持ってくるのでマイナス
  #Aiの値が変化したとき、そのAiまででの仕事の報酬の最大値を答えに加える
 pos+=1
print(ans)